{"version":3,"file":"main.esm.js","sources":["../src/view.ts","../src/computed.ts","../src/store.ts"],"sourcesContent":["import {FC, useCallback, useEffect, useMemo, useState} from 'react'\nimport {observe, unobserve} from '@nx-js/observer-util'\n\nexport function view<T>(Comp: FC<T>): FC<T> {\n  // use a hook based reactive wrapper when we can\n  const ReactiveComp = (props: T) => {\n    // use a dummy setState to update the component\n    const [, setState] = useState()\n    const forceUpdate = useCallback(() => setState({}), [])\n\n    // create a memoized reactive wrapper of the original component (render)\n    // at the very first run of the component function\n    const render = useMemo(\n      () =>\n        observe(Comp, {\n          scheduler: forceUpdate,\n          lazy: true\n        }),\n      [Comp]\n    )\n\n    // cleanup the reactive connections after the very last render of the component\n    useEffect(() => () => unobserve(render), [])\n\n    // run the reactive render instead of the original one\n    return render(props)\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name\n\n  return ReactiveComp\n}\n","import {observe} from '@nx-js/observer-util'\n\nconst computedPlaceHolder = {}\n\n/**\n * wrap value provider to computed value getter.\n * a computed value getter will cache provider compute result and re-compute when depended observable values change\n * todo fix circle: getA() => getB() => getC() => getA()\n * @param provider value provider\n */\nexport function computed<T>(provider: () => T) {\n  let value = computedPlaceHolder\n  // call getter immediately may throw Error when observable object has self-reference, so use placeholder and set lazy to true\n  const reaction = observe(provider, {\n    lazy: true,\n    scheduler: (r: typeof provider) => {\n      value = r()\n    }\n  })\n  return function computedValueGetter(): T {\n    if (value === computedPlaceHolder) value = reaction()\n    return value as T\n  }\n}\n","import {isObservable, observable} from '@nx-js/observer-util'\nimport {useMemo} from 'react'\nimport {computed} from './computed'\n\n/**\n * create a shared store outside components\n * @param obj object contains init state values\n * @param wrapGetterToComputed whether to wrap getters to computed values. default value is true\n */\nexport function createStore<T extends object>(obj: T, wrapGetterToComputed = true) {\n  if (isObservable(obj)) return obj\n  if (wrapGetterToComputed) {\n    for (const k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        const d = Object.getOwnPropertyDescriptor(obj, k)\n        if (d === undefined) continue\n        const getter = d.get\n        const setter = d.set\n        if (getter) {\n          Object.defineProperty(obj, k, {\n            get: computed(getter),\n            set: setter\n          })\n        }\n      }\n    }\n  }\n  return observable(obj)\n}\n\n/**\n * when creating local store inside functional component call this hook instead of createStore to avoid recreation during rendering\n * @param obj object contains init state values\n * @param wrapGetterToComputed whether to wrap getters to computed values. default value is true\n */\nexport function useLocalStore<T extends object>(obj: T, wrapGetterToComputed = true) {\n  return useMemo(() => createStore(obj, wrapGetterToComputed), [])\n}\n"],"names":[],"mappings":";;;SAGgB,IAAI,CAAI,IAAW;IAEjC,IAAM,YAAY,GAAG,UAAC,KAAQ;QAEtB,IAAA,KAAe,QAAQ,EAAE,EAAtB,QAAQ,QAAc,CAAA;QAC/B,IAAM,WAAW,GAAG,WAAW,CAAC,cAAM,OAAA,QAAQ,CAAC,EAAE,CAAC,GAAA,EAAE,EAAE,CAAC,CAAA;QAIvD,IAAM,MAAM,GAAG,OAAO,CACpB;YACE,OAAA,OAAO,CAAC,IAAI,EAAE;gBACZ,SAAS,EAAE,WAAW;gBACtB,IAAI,EAAE,IAAI;aACX,CAAC;SAAA,EACJ,CAAC,IAAI,CAAC,CACP,CAAA;QAGD,SAAS,CAAC,cAAM,OAAA,cAAM,OAAA,SAAS,CAAC,MAAM,CAAC,GAAA,GAAA,EAAE,EAAE,CAAC,CAAA;QAG5C,OAAO,MAAM,CAAC,KAAK,CAAC,CAAA;KACrB,CAAA;IAED,YAAY,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,IAAI,CAAA;IAExD,OAAO,YAAY,CAAA;AACrB;;AC7BA,IAAM,mBAAmB,GAAG,EAAE,CAAA;AAQ9B,SAAgB,QAAQ,CAAI,QAAiB;IAC3C,IAAI,KAAK,GAAG,mBAAmB,CAAA;IAE/B,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,EAAE;QACjC,IAAI,EAAE,IAAI;QACV,SAAS,EAAE,UAAC,CAAkB;YAC5B,KAAK,GAAG,CAAC,EAAE,CAAA;SACZ;KACF,CAAC,CAAA;IACF,OAAO,SAAS,mBAAmB;QACjC,IAAI,KAAK,KAAK,mBAAmB;YAAE,KAAK,GAAG,QAAQ,EAAE,CAAA;QACrD,OAAO,KAAU,CAAA;KAClB,CAAA;AACH,CAAC;;SCde,WAAW,CAAmB,GAAM,EAAE,oBAA2B;IAA3B,qCAAA,EAAA,2BAA2B;IAC/E,IAAI,YAAY,CAAC,GAAG,CAAC;QAAE,OAAO,GAAG,CAAA;IACjC,IAAI,oBAAoB,EAAE;QACxB,KAAK,IAAM,CAAC,IAAI,GAAG,EAAE;YACnB,IAAI,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE;gBACzB,IAAM,CAAC,GAAG,MAAM,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;gBACjD,IAAI,CAAC,KAAK,SAAS;oBAAE,SAAQ;gBAC7B,IAAM,MAAM,GAAG,CAAC,CAAC,GAAG,CAAA;gBACpB,IAAM,MAAM,GAAG,CAAC,CAAC,GAAG,CAAA;gBACpB,IAAI,MAAM,EAAE;oBACV,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,EAAE;wBAC5B,GAAG,EAAE,QAAQ,CAAC,MAAM,CAAC;wBACrB,GAAG,EAAE,MAAM;qBACZ,CAAC,CAAA;iBACH;aACF;SACF;KACF;IACD,OAAO,UAAU,CAAC,GAAG,CAAC,CAAA;AACxB,CAAC;AAOD,SAAgB,aAAa,CAAmB,GAAM,EAAE,oBAA2B;IAA3B,qCAAA,EAAA,2BAA2B;IACjF,OAAO,OAAO,CAAC,cAAM,OAAA,WAAW,CAAC,GAAG,EAAE,oBAAoB,CAAC,GAAA,EAAE,EAAE,CAAC,CAAA;AAClE,CAAC;;;;"}