{"version":3,"file":"main.cjs.js","sources":["../src/view.ts","../src/computed.ts","../src/store.ts"],"sourcesContent":["import {FC, useCallback, useEffect, useMemo, useState} from 'react'\nimport {observe, unobserve} from '@nx-js/observer-util'\n\nexport function view<T>(Comp: FC<T>): FC<T> {\n  // use a hook based reactive wrapper when we can\n  const ReactiveComp = (props: T) => {\n    // use a dummy setState to update the component\n    const [, setState] = useState()\n    const forceUpdate = useCallback(() => setState({}), [])\n\n    // create a memoized reactive wrapper of the original component (render)\n    // at the very first run of the component function\n    const render = useMemo(\n      () =>\n        observe(Comp, {\n          scheduler: forceUpdate,\n          lazy: true\n        }),\n      [Comp]\n    )\n\n    // cleanup the reactive connections after the very last render of the component\n    useEffect(() => () => unobserve(render), [])\n\n    // run the reactive render instead of the original one\n    return render(props)\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name\n\n  return ReactiveComp\n}\n","import {observe} from '@nx-js/observer-util'\n\nconst computedPlaceHolder = {}\n\n/**\n * wrap value provider to computed value getter.\n * a computed value getter will cache provider compute result and re-compute when depended observable values change\n * todo fix circle: getA() => getB() => getC() => getA()\n * @param provider value provider\n */\nexport function computed<T>(provider: () => T) {\n  let value = computedPlaceHolder\n  // call getter immediately may throw Error when observable object has self-reference, so use placeholder and set lazy to true\n  const reaction = observe(provider, {\n    lazy: true,\n    scheduler: (r: typeof provider) => {\n      value = r()\n    }\n  })\n  return function computedValueGetter(): T {\n    if (value === computedPlaceHolder) value = reaction()\n    return value as T\n  }\n}\n","import {isObservable, observable} from '@nx-js/observer-util'\nimport {useMemo} from 'react'\nimport {computed} from './computed'\n\n/**\n * create a shared store outside components\n * @param obj object contains init state values\n * @param wrapGetterToComputed whether to wrap getters to computed values. default value is true\n */\nexport function createStore<T extends object>(obj: T, wrapGetterToComputed = true) {\n  if (isObservable(obj)) return obj\n  if (wrapGetterToComputed) {\n    for (const k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        const d = Object.getOwnPropertyDescriptor(obj, k)\n        if (d === undefined) continue\n        const getter = d.get\n        const setter = d.set\n        if (getter) {\n          Object.defineProperty(obj, k, {\n            get: computed(getter),\n            set: setter\n          })\n        }\n      }\n    }\n  }\n  return observable(obj)\n}\n\n/**\n * when creating local store inside functional component call this hook instead of createStore to avoid recreation during rendering\n * @param obj object contains init state values\n * @param wrapGetterToComputed whether to wrap getters to computed values. default value is true\n */\nexport function useLocalStore<T extends object>(obj: T, wrapGetterToComputed = true) {\n  return useMemo(() => createStore(obj, wrapGetterToComputed), [])\n}\n"],"names":["useState","useCallback","useMemo","observe","useEffect","unobserve","isObservable","observable"],"mappings":";;;;;;WAGgB,IAAI,CAAI,IAAW;MAEjC,IAAM,YAAY,GAAG,UAAC,KAAQ;UAEtB,IAAA,KAAeA,cAAQ,EAAE,EAAtB,QAAQ,QAAc,CAAA;UAC/B,IAAM,WAAW,GAAGC,iBAAW,CAAC,cAAM,OAAA,QAAQ,CAAC,EAAE,CAAC,GAAA,EAAE,EAAE,CAAC,CAAA;UAIvD,IAAM,MAAM,GAAGC,aAAO,CACpB;cACE,OAAAC,oBAAO,CAAC,IAAI,EAAE;kBACZ,SAAS,EAAE,WAAW;kBACtB,IAAI,EAAE,IAAI;eACX,CAAC;WAAA,EACJ,CAAC,IAAI,CAAC,CACP,CAAA;UAGDC,eAAS,CAAC,cAAM,OAAA,cAAM,OAAAC,sBAAS,CAAC,MAAM,CAAC,GAAA,GAAA,EAAE,EAAE,CAAC,CAAA;UAG5C,OAAO,MAAM,CAAC,KAAK,CAAC,CAAA;OACrB,CAAA;MAED,YAAY,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,IAAI,CAAA;MAExD,OAAO,YAAY,CAAA;EACrB;;EC7BA,IAAM,mBAAmB,GAAG,EAAE,CAAA;AAQ9B,WAAgB,QAAQ,CAAI,QAAiB;MAC3C,IAAI,KAAK,GAAG,mBAAmB,CAAA;MAE/B,IAAM,QAAQ,GAAGF,oBAAO,CAAC,QAAQ,EAAE;UACjC,IAAI,EAAE,IAAI;UACV,SAAS,EAAE,UAAC,CAAkB;cAC5B,KAAK,GAAG,CAAC,EAAE,CAAA;WACZ;OACF,CAAC,CAAA;MACF,OAAO,SAAS,mBAAmB;UACjC,IAAI,KAAK,KAAK,mBAAmB;cAAE,KAAK,GAAG,QAAQ,EAAE,CAAA;UACrD,OAAO,KAAU,CAAA;OAClB,CAAA;EACH,CAAC;;WCde,WAAW,CAAmB,GAAM,EAAE,oBAA2B;MAA3B,qCAAA,EAAA,2BAA2B;MAC/E,IAAIG,yBAAY,CAAC,GAAG,CAAC;UAAE,OAAO,GAAG,CAAA;MACjC,IAAI,oBAAoB,EAAE;UACxB,KAAK,IAAM,CAAC,IAAI,GAAG,EAAE;cACnB,IAAI,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE;kBACzB,IAAM,CAAC,GAAG,MAAM,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;kBACjD,IAAI,CAAC,KAAK,SAAS;sBAAE,SAAQ;kBAC7B,IAAM,MAAM,GAAG,CAAC,CAAC,GAAG,CAAA;kBACpB,IAAM,MAAM,GAAG,CAAC,CAAC,GAAG,CAAA;kBACpB,IAAI,MAAM,EAAE;sBACV,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,EAAE;0BAC5B,GAAG,EAAE,QAAQ,CAAC,MAAM,CAAC;0BACrB,GAAG,EAAE,MAAM;uBACZ,CAAC,CAAA;mBACH;eACF;WACF;OACF;MACD,OAAOC,uBAAU,CAAC,GAAG,CAAC,CAAA;EACxB,CAAC;AAOD,WAAgB,aAAa,CAAmB,GAAM,EAAE,oBAA2B;MAA3B,qCAAA,EAAA,2BAA2B;MACjF,OAAOL,aAAO,CAAC,cAAM,OAAA,WAAW,CAAC,GAAG,EAAE,oBAAoB,CAAC,GAAA,EAAE,EAAE,CAAC,CAAA;EAClE,CAAC;;;;;;;;;;;;;;;"}